name: Bump Minor Version on Push (Groovy & Package Manifest)

on:
  push:
    branches:
      - main

jobs:
  bump-version:
    # Only run the job if the push commit message does NOT contain [skip ci]
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set git user
        run: |
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Get current version and calculate new version from source file
        id: version_calc
        run: |
          SOURCE_FILE="app/volvo-cars-app.groovy" # Define the source of truth file

          # Check if the source file exists
          if [ ! -f "$SOURCE_FILE" ]; then
            echo "Error: Source file '$SOURCE_FILE' not found. Cannot determine current version."
            exit 1
          fi

          # Extract the current version string (e.g., '0.9.0') from the source file
          # Use awk to find the line and extract the quoted string after 'return'
          CURRENT_VERSION=$(awk '/String appVersion\(\) \{ return '\''/{match($0, /'\''([0-9]+\.[0-9]+\.[0-9]+)'\''/, arr); print arr[1]; exit}' "$SOURCE_FILE")

          if [ -z "$CURRENT_VERSION" ]; then
            echo "Error: Could not extract current version from appVersion() line in '$SOURCE_FILE'."
            exit 1
          fi

          echo "Current version extracted from $SOURCE_FILE: $CURRENT_VERSION"

          # Parse major, minor, patch parts
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Calculate the new minor version, reset patch to 0
          # Use 10# to ensure decimal interpretation in case of leading zeros
          NEW_MINOR=$((10#$MINOR + 1))
          NEW_VERSION="$MAJOR.$NEW_MINOR.0"

          echo "Calculated new version: $NEW_VERSION"

          # Set output variables for use in subsequent steps
          echo "current_version=${CURRENT_VERSION}" >> "$GITHUB_OUTPUT" # Store current for replacement
          echo "new_version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"      # Store new version

      - name: Update version in all Groovy files
        run: |
          # Retrieve the current and new versions from the previous step's outputs
          NEW_VERSION="${{ steps.version_calc.outputs.new_version }}"
          CURRENT_VERSION="${{ steps.version_calc.outputs.current_version }}" # Not strictly needed for this sed command but good for logging

          if [ -z "$NEW_VERSION" ]; then
             echo "Error: New version information is missing from the previous step."
             exit 1
          fi

          echo "Searching for all .groovy files and updating version to ${NEW_VERSION}..."

          # Find all .groovy files recursively and loop through them
          # -print0 and read -d $'\0' handle filenames with spaces or special characters
          find . -name '*.groovy' -print0 | while IFS= read -r -d $'\0' file; do
            echo "Processing file: $file"

            # Use sed -E (Extended Regex) for in-place replacement
            # Address the line containing 'String appVersion() { return ''
            # Then substitute the content inside the single quotes on that line
            # -i flag modifies the file in-place. On Linux (used by GitHub Actions), -i alone works.
            # We use double quotes around the sed command so the shell variable $NEW_VERSION is expanded.
            # ERE requires escaping literal () and {}
            # Pattern '/String appVersion\(\) \{\ return '/ - finds the line
            # Command 's/'[^']*'/'${NEW_VERSION}'/' - on the matching line, substitutes version
            # This looks for ' any-non-quote-chars ' and replaces it with '${NEW_VERSION}'
            sed -E "/String appVersion\\(\\) \\{\\ return '/ s/'[^']*'/'${NEW_VERSION}'/" "$file"

            # Check if sed executed successfully (though sed often doesn't exit non-zero for no match)
            # You could add a grep check here if needed:
            # if ! grep "String appVersion() { return '${NEW_VERSION}'" "$file" > /dev/null; then
            #   echo "Warning: Failed to update version in $file"
            # fi

          done

          echo "Finished updating groovy files."

      - name: Update version in packageManifest.json
        run: |
          PACKAGE_MANIFEST_FILE="packageManifest.json"
          NEW_VERSION="${{ steps.version_calc.outputs.new_version }}"

          if [ -z "$NEW_VERSION" ]; then
             echo "Error: New version information is missing from the previous step."
             exit 1
          fi

          if [ ! -f "$PACKAGE_MANIFEST_FILE" ]; then
            echo "Error: Package manifest file '$PACKAGE_MANIFEST_FILE' not found."
            exit 1
          fi

          echo "Updating version in ${PACKAGE_MANIFEST_FILE} to ${NEW_VERSION}..."

          # Use jq to update the version fields
          # .version = $new_v              -> updates the top-level version
          # .apps[].version = $new_v       -> updates the version in all app objects in the apps array
          # .drivers[].version = $new_v    -> updates the version in all driver objects in the drivers array
          jq --arg new_v "$NEW_VERSION" '
            (.version = $new_v) |
            (.apps[]?.version = $new_v) |   # Use ?. to handle potentially missing 'apps' or 'drivers' or version field gracefully
            (.drivers[]?.version = $new_v)
          ' "$PACKAGE_MANIFEST_FILE" > "$PACKAGE_MANIFEST_FILE.tmp" && mv "$PACKAGE_MANIFEST_FILE.tmp" "$PACKAGE_MANIFEST_FILE"

          echo "Finished updating ${PACKAGE_MANIFEST_FILE}."

      - name: Commit and Push changes
        run: |
          # Check if any groovy or the package manifest file were modified
          if [[ $(git diff --stat -- "*.groovy" "packageManifest.json") != '' ]]; then
            echo "Changes detected in .groovy files or packageManifest.json. Committing and pushing."
            git add "*.groovy" packageManifest.json # Add all modified groovy files and the manifest file
            git commit -m "Bump version to ${{ steps.version_calc.outputs.new_version }} [skip ci]"
            git push
          else
            echo "No changes detected in specified files. Skipping commit."
          fi